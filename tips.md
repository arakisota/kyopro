## tipsまとめ
問題を解く上で、コツや覚えておくべきことなどをメモする

#### 配列編
- ソートしても答えが変わらない問題は事前にソートしておくことで、扱いやすくなる
- ある区間内の問題を考えるときは差分に注目するといい
    - しゃくとり法
    - https://qiita.com/drken/items/ecd1a472d3a0e7db8dce
- 二分探索をするときに配列の両端に番兵を入れることで処理がシンプルになりやすい
    - 番兵は実行に影響を与えないが、処理が楽になる仮想的なindexのこと
- 優先度付きキューを使う
    - 要素の追加や削除があるときにソートの代わりに使う
- 全体の中で何番目かを求めるとき
    - 座標圧縮（座圧）をすると扱いやすい
    - 計算量はO(N*logN)
- 桁数が関わってくる問題は文字列として受け取って、listなどで扱う方がやりやすい。

#### クエリ問題編
- 「全体に何かする」問題はoffset的なものを使って高速化するのが割と定石
    - 優先度付きキューなど
        - 優先度付きキューはただのヒープ構造
        - https://qiita.com/T_Wakasugi/items/dac6eb77a3cace54f95e

#### 選択肢のある行動編
- いくつかの選択肢のある行動を取るときは、「順番を入れ替えて損をしないか」を考えて、考えやすいように操作の順番を決めてしまうといいことが多い
    - ただの全探索でいけることがある

#### 整数編
- 素因数分解
    - エラストネス

#### DP編
- どういう時にDPを使うといいのか？
    - 全探索をするときに時間の制約的に効率よくしたい時
        - DPは全探索を効率化したものとして覚えておくのが良い
- DPの問題で必要なこと
    - DPテーブルをうまく設計する
        - 何を状態に持つか
    - DPテーブルをうまく埋める
- DPは問題をうまく言い換えることでやったことのあるDPの問題にすることができる
    - そのためにもDPの問題にはたくさん慣れることで初見でも対応できるようになる
- 全探索のイメージ
    - 全探索を効率化したもの
    - 漸化式を立てて、プログラムに落とし込んだもの

#### 計算量編
- 値がかなり大きくなる時は先に割っておく
    - modは割り算以外は先に割っても問題ないため、先にmodを取っておくことでオーバーフロー対策になる
- 事前に別の計算をしておくことで、ループを一つ減らせることがある
- PyPy3は再起に弱いため、再起の計算を使うときはPython3を使用する

#### わからない問題に出会った時
- 難しい問題が出てきたらとりあえず軽めの数字で実際に試してみる
- 意外と数式的に計算してみるといけることがある
    - 二つの数の和が一定なら、平方完成すれば、最大・最小は容易に求めることができる
- 制約をみると全探索しても全然間に合うパターンがある
- 順位表を見て、速攻解けている人がいるということは何か気付けばすぐできる問題の可能性もある
- 制約が小さいときはシミュレーションをして答える

#### その他
- 対数は安易に使ってはいけない
    - 数字が大きくなると誤差がつもりテストケースにひっかかることが多い
    - というより、引っかかるようにテストケースが作られている
- itertoolsを使えば、順列や組み合わせの問題は大抵解ける
    - https://qiita.com/anmint/items/37ca0ded5e1d360b51f3
- a~zの文字列を作るにはライブラリを使うと楽
    - from string import ascii_lowercase
- 四捨五入するときにround関数を使うが、注意する
    - round関数は小数部分が0.5の時に、偶数に近い方に丸められる性質がある
    - 例
        - round(1.5) == 2だが、round(0.5) == 0になってしまう
    - 対策
        - 十分小さい数(0.0005など)を加えてからround関数を使用する
- PyPy3にはNumpy入ってないため、Numpyを使うならPython3で実装する。